from django.db import models
from archivebackend.constants import *

# Create your models here.

class RemotePeer(models.Model):
    site_name = models.CharField(max_length=titleLength)
    site_adress = models.CharField(max_length=maxFileNameLength)
    mirror_files = models.BooleanField(blank=True, default=False)
    last_checkin = models.DateTimeField()

class Author(models.Model):
    name = models.CharField(max_length=authorLength)
    birthday = models.DateField(blank=True, null=True)
    
    #used to store authors retrieved from peer networks
    from_remote = models.ForeignKey(RemotePeer, blank=True, null=True, on_delete=models.CASCADE)
    alias_of_local = models.ForeignKey("Author", blank=True, null=True, on_delete=models.SET_NULL)
    remote_id = models.BigIntegerField(blank=True, null=True)

    def __str__(self) -> str:
        return self.name + " - " + str(self.birthday)

class AuthorDescriptionTranslation(models.Model):
    describes = models.ForeignKey(Author, on_delete=models.CASCADE)
    language_iso_639_format = models.CharField(max_length=2)
    name_translation = models.CharField(max_length=authorLength)
    description = models.CharField(max_length=descriptionLength, blank=True)
    
    #used to store descriptions retrieved from peer networks
    from_remote = models.ForeignKey(RemotePeer, blank=True, null=True, on_delete=models.CASCADE)
    remote_id = models.BigIntegerField(blank=True, null=True)

    def __str__(self) -> str:
        return self.name_translation + " - (" + self.language_iso_639_format + ")"

    class Meta:
        unique_together = ["describes", "language_iso_639_format"]


class AbstractDocument(models.Model):
    """Represents an abstract document. For example, 'the first Harry Potter book', regardless of language, edition, print, etc.
    A workable id system must be established on a per-project basis. 
    A possibility is <the author + year + original book title in the original language, in common latin transliteration>
    """
    human_readable_id = models.CharField(max_length=200, unique=True)
    original_publication_date = models.DateField(blank=True, null=True)
    authors = models.ManyToManyField(Author)
    
    #used to store abstract documents retrieved from peer networks
    from_remote = models.ForeignKey(RemotePeer, blank=True, null=True, on_delete=models.CASCADE)
    remote_id = models.BigIntegerField(blank=True, null=True)
    alias_of_local = models.ForeignKey("AbstractDocument", blank=True, null=True, on_delete=models.SET_NULL)

    def __str__(self) -> str:
        return self.human_readable_id

class AbstractDocumentDescriptionTranslation(models.Model):
    """Provides functionality for adding titles and descriptions of abstract documents in multiple languages"""
    describes = models.ForeignKey(AbstractDocument, on_delete=models.CASCADE)
    language_iso_639_format = models.CharField(max_length=2)
    title_translation = models.CharField(max_length=titleLength)
    description = models.CharField(max_length=descriptionLength, blank=True)
    
    #used to store document descriptions retrieved from peer networks
    from_remote = models.ForeignKey(RemotePeer, blank=True, null=True, on_delete=models.CASCADE)
    remote_id = models.BigIntegerField(blank=True, null=True)

    def __str__(self) -> str:
        return self.title_translation + " - (" + self.language_iso_639_format + ")"

    class Meta:
        unique_together = ["describes", "language_iso_639_format"]

class existanceType(models.IntegerChoices):
    """Describes how the edition exists on this server"""
    LOCAL = 0 #It was uploaded and originated on this server.
    AUTOGENERATED = 1 #It is auto generated on our server from a different file (can be any type)
    REMOTE = 2 #It exists on a remote server, but isnt mirrored. Just links to the remote file. (saves storage)
    MIRROREDREMOTE = 3 #It exists on a remote server, and is copied locally by this instance for reliability/speed/archival purposes.
    LOCALFORK = 4 #Fully locally owned copy, with an origin on a remote server.

class Edition(models.Model):
    edition_of = models.ForeignKey(AbstractDocument, on_delete=models.CASCADE)
    publication_date = models.DateField(blank=True, null=True)
    language_iso_639_format = models.CharField(max_length=2)
    file_format = models.CharField(max_length=10)
    title = models.CharField(max_length=titleLength)
    description = models.CharField(max_length=descriptionLength)
    additional_authors = models.ManyToManyField(Author, blank=True)
    
    #precalculated hyperlink value to quickly serve users
    file_url = models.CharField(max_length=maxFileNameLength, blank=True)
    #how is the document saved.
    existance_type = models.IntegerField(
        choices=existanceType.choices,
        default=existanceType.LOCAL,
    )
    #Following are specific to the type of file
    generated_from = models.ForeignKey("Edition", on_delete=models.CASCADE, blank=True, null=True)
    remote_id = models.BigIntegerField(blank=True, null=True)
    from_remote = models.ForeignKey(RemotePeer, on_delete=models.SET_NULL, blank=True, null=True)

    def __str__(self) -> str:
        return self.title + " - (" + self.language_iso_639_format + ") - " + self.file_format